// Code generated by sqlc. DO NOT EDIT.
// source: employee.sql

package employee

import (
	"context"

	"github.com/google/uuid"
)

const createEmployee = `-- name: CreateEmployee :one
INSERT INTO employees (employee_id, name, job_position, compensation)
VALUES ($1, $2, $3, $4)
RETURNING id, employee_id, company_id, name, job_position, compensation
`

type CreateEmployeeParams struct {
	EmployeeID   uuid.UUID   `json:"employeeID"`
	Name         string      `json:"name"`
	JobPosition  JobPosition `json:"jobPosition"`
	Compensation string      `json:"compensation"`
}

func (q *Queries) CreateEmployee(ctx context.Context, arg CreateEmployeeParams) (Employees, error) {
	row := q.queryRow(ctx, q.createEmployeeStmt, createEmployee,
		arg.EmployeeID,
		arg.Name,
		arg.JobPosition,
		arg.Compensation,
	)
	var i Employees
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.CompanyID,
		&i.Name,
		&i.JobPosition,
		&i.Compensation,
	)
	return i, err
}

const deleteEmployee = `-- name: DeleteEmployee :exec
DELETE
FROM employees
WHERE employee_id = $1
`

func (q *Queries) DeleteEmployee(ctx context.Context, employeeID uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteEmployeeStmt, deleteEmployee, employeeID)
	return err
}

const getEmployee = `-- name: GetEmployee :one
SELECT id, employee_id, company_id, name, job_position, compensation
FROM employees
WHERE employee_id = $1
LIMIT 1
`

func (q *Queries) GetEmployee(ctx context.Context, employeeID uuid.UUID) (Employees, error) {
	row := q.queryRow(ctx, q.getEmployeeStmt, getEmployee, employeeID)
	var i Employees
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.CompanyID,
		&i.Name,
		&i.JobPosition,
		&i.Compensation,
	)
	return i, err
}

const listAllEmployees = `-- name: ListAllEmployees :many
SELECT id, employee_id, company_id, name, job_position, compensation
FROM employees
ORDER BY name
`

func (q *Queries) ListAllEmployees(ctx context.Context) ([]Employees, error) {
	rows, err := q.query(ctx, q.listAllEmployeesStmt, listAllEmployees)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Employees{}
	for rows.Next() {
		var i Employees
		if err := rows.Scan(
			&i.ID,
			&i.EmployeeID,
			&i.CompanyID,
			&i.Name,
			&i.JobPosition,
			&i.Compensation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaginatedEmployees = `-- name: ListPaginatedEmployees :many
SELECT id, employee_id, company_id, name, job_position, compensation
FROM employees
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListPaginatedEmployeesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListPaginatedEmployees(ctx context.Context, arg ListPaginatedEmployeesParams) ([]Employees, error) {
	rows, err := q.query(ctx, q.listPaginatedEmployeesStmt, listPaginatedEmployees, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Employees{}
	for rows.Next() {
		var i Employees
		if err := rows.Scan(
			&i.ID,
			&i.EmployeeID,
			&i.CompanyID,
			&i.Name,
			&i.JobPosition,
			&i.Compensation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
